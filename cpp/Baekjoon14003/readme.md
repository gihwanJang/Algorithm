# (14003) 가장 긴 증가하는 부분 수열 5
## :100: Algorithm
[문제 바로가기](https://www.acmicpc.net/problem/14003)
#
## 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.
#
## 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)
#
## 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.
#
## 풀이
해당 문제는 이분 탐색과 다이나믹 프로그래밍을 활용하면 해결 할 수 있는 문제입니다.  

가장 긴 증가하는 부분 수열의 경우 DP로 풀 경우 2가지의 풀이로 풀 수 있습니다.  

첫 번째는 시간 복잡도가 n^2이 되며 점화 식은 아래와 같습니다.  
if(num[i] < num[j] && i < j) -> dp[j] = max(dp[j], dp[i] + 1)  
해당 문제에서 요구하는 입력에 대하여 해당 알고리즘을 실행하게되면 시간 초과가 발생하게 됩니다.  

두 번째는 시간 복잡도가 nlogn이 되며 해당 방식은 아래와 같습니다.  
각 인덱스에 대하여 부분수열에 들어갈 수 있는 수를 저장합니다.  
인덱스 i에 대하여 리스트가 비어있거나 마지막 값보다 nums[i]값이 큰경우 마지막에 넣을 수 있습니다.  
그렇지 않다면 리스트에서 해당 값이 들어 갈 수 있는 위치를 찾습니다.  
이때 해당 위치를 이분 탐색으로 찾게된다면 logn의 시간 복잡도를 통하여 찾을 수 있습니다.  

하지만 두 번째의 알고리즘으로 리스트를 만들게 된다면 부분수열의 길이는 정확하게 구할 수 있으나 정확한 부분 수열을 찾을 수는 없습니다.  
그러므로 위의 과정을 반복하며 i번째 인덱스가 리스트에 몇번 째인지를 같이 기억해 놓으면 부분수열을 역추역 할 수 있습니다.  

주어진 입력을 예시로 위의 과정을 따라가 보겠습니다.  
## 입력 -> n : 6, nums : 10, 20, 10, 30, 20, 50  

### i = 0
- DP  

|0|
|---|
|10|


- idx

|10|20|10|30|20|50|
|---|---|---|---|---|---|
|0|0|0|0|0|0|

### i = 1
- DP  

|0|1|
|---|---|
|10|20|


- idx

|10|20|10|30|20|50|
|---|---|---|---|---|---|
|0|1|0|0|0|0|

### i = 2
- DP  

|0|1|
|---|---|
|10|20|


- idx

|10|20|10|30|20|50|
|---|---|---|---|---|---|
|0|1|0|0|0|0|

### i = 3
- DP  

|0|1|2|
|---|---|---|
|10|20|30|


- idx

|10|20|10|30|20|50|
|---|---|---|---|---|---|
|0|1|0|2|0|0|

### i = 4
- DP  

|0|1|2|
|---|---|---|
|10|20|30|


- idx

|10|20|10|30|20|50|
|---|---|---|---|---|---|
|0|1|0|2|1|0|

### i = 5
- DP  

|0|1|2|3|
|---|---|---|---|
|10|20|30|50|


- idx

|10|20|10|30|20|50|
|---|---|---|---|---|---|
|0|1|0|2|1|3|


위의 과정에서 최종적으로 만들어진 idx테이블에 대하여 dp의 마지막 인덱스 부터 처음 까지 차례대로 비교해 가며 같은 값만 스텍에 담습니다.  

이후 해당 스텍의 사이즈와 하나씩 값을 빼 출력해 주시면 됩니다.

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> getDP(vector<int>&nums, vector<int>&nums_idx, int n)
{
    int l, r, mid;
    vector<int> DP;

    for(int i = 0; i < n; ++i)
    {
        if(DP.size() == 0 || nums[i] > DP.back())
        {
            DP.push_back(nums[i]);
            nums_idx[i] = DP.size() - 1;
        }
        else
        {
            l = 0;
            r = DP.size()-1;
            
            while (l < r)
            {
                mid = (l + r) / 2;
                
                if (DP[mid] >= nums[i]) r = mid;
                else l = mid + 1;
            }

            DP[l] = nums[i];
            nums_idx[i] = l;
        }
    }

    return DP;
}

vector<int> getLIS(vector<int>&nums, int n)
{
    
    vector<int> LIS;
    vector<int> nums_idx(n);
    vector<int> DP = getDP(nums, nums_idx, n);
    int idx = DP.size() - 1;

    for (int i = n-1; i >= 0; --i)
        if (nums_idx[i] == idx)
        {
            --idx;
            LIS.push_back(nums[i]);
        }

    return LIS;
}

int main(int argc, char const *argv[])
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int n; 
    cin >> n; 

    vector<int> nums(n);
    for (int i = 0; i < n; ++i)
        cin >> nums[i];

    vector<int> LIS = getLIS(nums, n);
    cout << LIS.size() << "\n";
    for(int i = LIS.size()-1; i >= 0; --i)
        cout << LIS[i] << " ";
    return 0;
}
```