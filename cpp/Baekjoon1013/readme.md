# (1013) Contcat
## :100: Algorithm
[문제 바로가기](https://www.acmicpc.net/problem/16724)
#
## 문제
“무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”
푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.

이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.

전파의 기본 단위는 { 0 , 1 } 두 가지로 구성되어있으며, x+ ( ) 는 임의의 개수(최소 1개) x의 반복으로 이루어진 전파의 집합을 나타낸다.

(xyx)+ ( ) 는 괄호 내의 xyx의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.

- 1+ = { 1, 11, 111, 1111, 11111, … }
- 10+ = { 10, 100, 1000, 10000, 100000, … }
- (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }
- (1001)+ = { 1001, 10011001, 100110011001, … }
- 10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }
- (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }

반복을 의미하는 + 외에도 or 를 의미하는 | 기호가 있다. { x | y } 는 x 혹은 y 를 의미하는 것으로, { 0+ | 1+ } 는 { 0 , 1 , 00 , 11 , 000 , 111 , … } 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.

- (100 | 11)+ = { 100 , 11 , 10011 , 11100 , 1110011100 , 100111111100100, … }

최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.

- (100+1+ | 01)+

김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.
#
## 입력
입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, { 0, 1 }만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 (1 ≤ N ≤ 200)의 범위를 갖는다.
#
## 출력
각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.
#
## 풀이
해당 문제는 스택과 분기 조건문을 이용하면 해결 할 수 있는 문제입니다.  

우선 해당 문제는 정규표현 식을 이해하여야 문제를 이해 할 수 있으므로 정규표현 식에 대하여 간량히 살표보았습니다.  
문제의 정규표현식은 +,(),| 3가지의 표선식을 사용합니다.  

- 값+ : 해당 연산자의 바로 뒤의 값을 반복합니다.  
    - ex) 03+ -> 03333, 033
- (값) : 괄효 내부의 값을 반복합니다.  
    - ex) (03) -> 030303, 0303
- 값|값 : 두 값중 하나가 올 수 있습니다.   

해당 문제에서 검사해야할 정규식은 (100+1+ | 01)+로 괄호 안에있는 것을 반복하며 반복 되는 값은 100+1+이거나 01이 될 수 있습니다.  
100+1+의 경우 100뒤에 0이 몇개든 붙을 수 있으며 이 뒤에 1이 몇개든 붙을 수 있습니다.

위의 내용을 바탕으로 아래의 방식대로 구현하였습니다.  

문자열을 입력 받은 후 해당 문자열을 뒤집어 해당 문자열 판별 함수에 넣습니다.  

해당 문자열을 판별하는 함수는 재귀적으로 돌아갑니다.  
해당 함수에 들어온 문자열의 길이가 0이면 yes 1이면 no가 출력 되며 2이상인 경우는 아래의 과정을 반복 합니다.  
2이상인 경우는 2가지의 경우로 나누어집니다.  
1. 맨뒤가 0일 경우
    - 0을 뒤에서 뺀다.
        - 맨뒤가 1일 경우 1을 삭제하고 해당 함수에 재귀적으로 삭제한 문자열을 재 반복한다.
        - 0일 경우 no를 출력한다.
2. 맨뒤가 1일 경우
    - 1을 뒤에서 뺀다.
        - 맨뒤가 0일 아닐때 까지 0을 빼면서 횟수를 카운트 한다.
            - 만약 0을 뺀 횟수가 1이하이면 no를 출력한다.
            - 아닐 경우 1+에 대하여 처리해한다.
                - 맨뒤가 1이 아닐때 까지 1을 빼면서 횟수를 카운트 한다.
                    - 횟수가 0일 경우 1+가 없음으로 no를 출력한다.
                    - 횟수가 1일 경우 더이상 건들일 수 없음으로 현재 문자열에 대하여 재 반복한다.
                    - 횟수가 2이상일 경우 맨뒤는 0이 되며 맨뒤 바로 앞의 값에 따라 다르게 된다.
                        - 맨뒤 바로 앞이 0인경우 1이 필요하게 되므로 1을 다시 넣어주고 해당 문자열에 대하여 재 반복한다.
                        - 맨뒤 바로 앞이 1인경우 해당 문자열에 대하여 재반복한다.

위의 함수를 입력받은 문자열을 뒤집후 실행해 줍니다.

```cpp
#include <algorithm>
#include <iostream>

using namespace std;

string isPattern(string&s) {
    if(s.empty()) return "YES";
    if(s.size() <= 1) return "NO";

    if(s.back() == '0') {
        s.pop_back();
        if(s.back() == '1') {
            s.pop_back();
            return isPattern(s);
        }
        else
            return "NO";
    }
    else {
        int cnt = 0;
        s.pop_back();

        while(!s.empty() && s.back() == '0'){
            ++cnt;
            s.pop_back();
        }

        if(cnt < 2) return "NO";
        else{
            cnt = 0;
            while(!s.empty() && s.back() == '1'){
                s.pop_back();
                ++cnt;
            }

            if(cnt == 0) return "NO";
            if(cnt == 1) return isPattern(s);

            if(s.size() > 1) {
                if(s[s.size()-2] == '0')
                    s.push_back('1');

                return isPattern(s);
            }
        }
    }
}

int main(int argc, char const *argv[]) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int T;
    cin >> T;

    while(T--) {
        string s;
        cin >> s;
        reverse(s.begin(), s.end());
        cout << isPattern(s) << "\n";
    }
    return 0;
}
```